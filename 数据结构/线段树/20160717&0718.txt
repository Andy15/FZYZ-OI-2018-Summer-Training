线段树及其应用
	支持：
		线段树优化
			线段树优化DP
				bzoj 2448
				bzoj 3594
				bzoj 3688
				bzoj 3711
			线段树优化建图
				最大流/费用流
					bzoj 2288
				最短路
					bzoj 3073
				2-SAT
					uoj 210
			数学相关
				优化矩乘（线性递推）
					bzoj 4085
				维护线性基
					bzoj 4184
		线段树上二分
			bzoj 2957
			bzoj 4293
			bzoj 4415
		维护区间的高级信息
			区间cmin一次函数
				bzoj 1568
				bzoj 4515
			区间cmincmax
				yzoj 对拍器12
		zkw线段树
		多维线段树
			堆套线段树
				bzoj 2006
				bzoj 4068
			权值线段树
				bzoj 2089/2090
			二维线段树
				bzoj 1513
				bzoj 2883
		补充11.28_1 线段树合并
　　　补充03.28 维护单调栈

bzoj 2448
	题意
		给出一条线段，在左端点点0与右端点n+1间有n个点(n<=2000)，并且在0到x之间的所有点都是有油的，在每个点钻井判断是否有油需要时间ti，求能够知道x的最坏情况下最少需要多少时间。
	题解
		f[i][j]表示仅考虑[i,j]区间的答案，则f[i][j]=min(max(f[i][k−1],f[k+1][j])+a[k]),i≤k≤j。维护出max的分界点后用一堆线段树维护即可。

bzoj 3594
	题意
		给定一个长度为N的区间，允许事先K次区间加1，求其最长不下降子序列。1<N<10000，1<K≤500，6s
	题解
		NK为500W,考虑设F[i][j]为到第i位区间加了j的次，i在LIS上的答案。
		每次拔都是拔i~N，这样不会使答案更劣。
		F[i][j] = max(F[i'][j']) + 1, a[i'] + j' <= a[i] + j , j' <= j
		发现每次都是求二位前缀最大值。树状数组维护。

bzoj 3688
	题意
		二维平面上有n个点(xi, yi)，现在这些点中取若干点构成一个集合S，对它们按照x坐标排序，顺次连接，将会构成一些连续上升、下降的折线，设其数量为f(S)。求满足f(S) = k的S集合个数mod100007。不存在两个点，x坐标值相等或y坐标值相等。n <= 50000，0 < k <= 10
	题解
		F[i][j][0/1]表示以排序后从左到右第i个点为结尾，末尾上升/下降，f(S) = j的集合个数。
		则F[i][j][k] += F[i'][j][k] + F[i'][j-1][k^1](需满足关系)
		线段树/树状数组维护。

bzoj 3711
	题意
		将N个小朋友分组，第i个小朋友希望它所在的组的人数不多于d[i]，不少于c[i]，求可以分组的数目最大值，以及到达最大值的方案数。N<=10^6,4s
	题解
		设f[i]为将前i个小朋友分组的最优解。
		f[i] = max(f[j] + 1), max(c[j+1],c[j+2],..,c[i]) <= i - j <= min(d[j+1],d[j+2],..,d[i])
		先考虑d的限制。设g[i] = min(j), 且i - j <= min(d[j + 1],d[j + 1],..,d[i]),则g[i]不降，可以双指针+线段树预处理。
		再考虑c的限制。用分治优化DP
		在Solve(l, r)时，求出(l, r)中c最大的位置，设为pos，以pos为分界线Solve(l, pos - 1), Solve(pos + 1, r)。
		由于C[pos]最大，所以C[pos] < i - j, i从max(c[k] + l, k)开始，决策j一开始的取值范围为[max(l,g[i]),i-c[k]]。用线段树求一次最大值即可。
		随着i增大，i不超过c[k]+k时，j的上限每次一定增大1，可以O(1)更新答案;对于某个i，j的下限可能会增大到g[i]，j的下限增大时，有l <= g[i] <= k-1，由于所有更新i的区间的[l,k-1]互不相交，所以每个i只会发生一次下限右移，对于每次右移线段树更新即可。
		当i增大到c[k]+k时，[k+c[k],r]内所有i的可行决策j的上限都为k-1，所以按g值不同分段，每一段用线段树区间更新。
		复杂度O(nlogn)
		好题。

bzoj 3073
	题意
		给N个点，由标号在[a, b]的点向[c, d]的全部连长度为1的双向边，求P点到其他点的距离。 N<=500000,M<=100000。
	题解
		线段树建图，用set维护还未还未访问过的点，BFS。

bzoj 4085
	题意
		支持对A数组区间加/减1,询问sigma (L<i<R) {F[A[i - 1] + 1] * F[A[i + 1] - 1]}, F[k] = F[k - 1] + a * F[k - 2] + b, F[1] = 1, F[2] = 2;
	题解
		用线段树维护序列，若区间加1，答案会变成sigma (L<i<R) {(F[A[i - 1] + 1] + a * F[A[i - 1]] + b) * F[A[i + 1] - 1]}。
		也就是需要维护F[A[i - 1]] * F[A[i + 1] - 1]和sigma{F[A[i + 1] - 1]}即可。前者类似于原式，后者是递推式可同理维护。
		对于区间减，将其化成F[k-2] = ...的形式，同理解决。
		然而卡常数，需要预处理次幂的等技巧。

bzoj 4184
	题意
		加入/删除一个数，求最大子集异或和。
	题解
		每个数存在的时间都是一些区间
		按照时间分治，维护线性基，时间复杂度O(nlognlogai)

bzoj 4293
	题意
		第i亩土地的草每天会长高a[i]厘米。m次操作，第i次收割在第d[i]天，并把所有高度大等b[i]的部分全部割去。求每次收割得到的草的高度总和。
	题解	
		首先生长后，在线段树上二分找到我们另当前杂草大于询问的位置
		输出=（所有杂草高度之和-（大于的土地数量*询问的高度））
		将得到的位置后面的杂草（因为全部高于当前）赋值为当前询问的高度

		这里都看上去很正常，复杂度似乎也可以接受O(nlogn)，那么我们开始写。。。写着写着我们发现如果要统计区间每一天增加多少怎么办。。。可以统计当前给定Ai的前缀和di对于一个区间[l,r]，我们有每天生长(d[r]−d[l−1])，那么就可以得到c天后生长多少了，但是我们同样可以发现，我们还需要维护一个b表示当前的树我们需要赋值成多少。。。可以写了？不能。
		当子树中存在一个b同时当前也有一个c要push_down的时候，我们两边都不能抛弃。令a表示是否保留当前值。那么对于每一段就有
			tree[u].sum=tree[u].sum×tree[u].a+(tree[u].r−tree[u].l+1)×tree[u].b+tree[u].c×(d[tree[u].r]−d[tree[u].l−1])
		同理最大值一定位于区间右边，那么最大值为
			tree[u].Max=tree[u].Max×tree[u].a+tree[u].b+tree[u].c×A[tree[u].r]
		但是我们对于处理下方就要分类讨论了，发现如果当前为u，下一层为uson，可以发现当tree[u].a==0的时候我们有完全覆盖，那么可以直接
			tree[uson].a=0，tree[uson].b=tree[u].b，tree[uson].c=tree[u].c
		然后根据上面的公式计算出sum和Max

		然后我们考虑当tree[u].a==1的情况，我们可以发现1代表保留原来的内容，那么我们保持原来的a不变，b、c累加（因为满足分配律）所以我们可以得到
			tree[uson].b=tree[uson].b+tree[u].b，tree[uson].c=tree[uson].c+tree[u].c
		那么我们可以发现这个时候增加的b其实只有tree[u].b,也可以发现增加的c也只有tree[u].c的部分，那么
			tree[uson].Max=tree[uson].Max+tree[u].b+tree[u].c×A[tree[uson].r]，tree[uson].sum=tree[uson].sum+tree[u].b×(tree[uson].r−tree[uson].l+1)+tree[u].c×(d[tree[uson].r]−d[tree[uson].l−1])

		当然对于左右区间搞完之后就可以将当前的设置为
			tree[u].a=1，tree[u].b=0，tree[u].c=0
		最艰难的部分已经过去，push_up就和平时的push_up没有什么不同。

bzoj 1568
	题意
		加入一条覆盖所有点的一次函数，求一个整点的最大值。(简化版：动态半平面交)
	题解
		标记永久化的应用
		维护若干个一次函数在每个端点的最大值
		首先将端点离散化(本题不需要)，线段树的每个区间维护的标记代表着覆盖这个区间的一条线段
		每次下放标记，利用标记永久化的思想，修改对应的区间标记
		若当前线段完全高于标记线段，则将当前线段进行标记
		若当前线段完全低于标记线段，则将当前线段扔掉
		若当前线段与标记线段有交点，考虑在上面的一部分是一个两条线段形成的分段函数，将长的线段作为当前节点的标记，短的线段继续下放
		复杂度O(nlog^2n)

bzoj 4515
	题意
		给一棵树，要求区间加一个一次函数，求单点最小值。
	题解
		先分成左右两条，在树链剖分，转成区间;可以根据dep差求出真实cmin的一次函数，用李超线段树解决。复杂度Nlog^3N

bzoj 2006
	题意
		给定一个长度为N的音符序列，一个超级和弦由连续的不少于L个不多于R个音符组成，价值为Ai和。求一首k个不同超级和弦构成的乐曲使价值最大。
		N，K<=500000
	题解
		考虑满足的区间已经不会超过N^2个，只需要以某种顺序贪心取出即可。
		用(i, l, r)表示一个以i为左端点，右端点在[l,r]中的最大价值。一开始把所有i和一个i能对应到的整个区间的答案统计放入堆中。
		那么每次取出最大元素，假设为(i, l, r),最大值为pos，那么放进去(i, l, pos - 1)和(i, pos + 1, r)，用线段树/ST表统计答案。
		由于每次加入的个数均为常数(2个)，复杂度为NlogN。

bzoj 4068
	题意
		有一些任务，每个任务在ti前完成就可以获得di价值。每个任务都需要一天。求最大收益。
		需要支持加入/删除一个任务。
		天数<=300000,Q<=300000,20s。
	题解
		对于一个所选任务集合，如果对于任意时刻i，i前面所选任务数都不超过i的话，那么这些任务可以全选。
		维护一棵线段树T，第i个位置一开始为i，每使用一个任务，[t,T]都要减1。
		插入一个任务：首先查询[t,T]的区间内第一个0的位置，记为k。
		如果没有0，那么可以直接加入这个任务。
		否则要么不用这个任务，要么拿这个任务去替换t在[1,k]里价值最小的任务。
		删除一个任务：如果没有使用，那么直接删除。
		否则[t,T]都要加1，然后找到最后一个0的位置k。
		那么要在备用任务集合中取出t在[k+1,T]里价值最大的任务，加入答案。
		于是再按t用两棵线段树分别维护两个集合即可。
		时间复杂度O(QlogT)。

bzoj 2089
	题意
		给出N个正整数a[1..N]，再给出K个关系符号（>、<或=）s[1..k]。
		选出一个长度为L的子序列，要求这个子序列的第i项和第i+1项的的大小关系为s[(i-1)mod K+1]。求出L的最大值。
		N,K<=500000,10s
	题解
		设F[i]表示到第i位拿出来的最长序列长度。
		F[i]=max(F[j]+1并且i,j满足F[j]对应的大小关系)
		DP成立因为能取多取了总是更优的，而F如果能取到一个最优值，那么每一步的转移都会成立，否则存在更优(不劣)的解。
		由于下一个符号是确定的，等于号的话，我们直接开一个数组记录哪一个值上一次出现的可行位置即可。
		小于号，丢到线段树里面，线段树对权值开，记录一段权值区间最大的已出现的f值，查询直接拿最大就好了。大于号同理。
		复杂度O(nlogn)。

bzoj 1513
	题意
		3D内落下长方体，求最高的高度。N<=20000。
	题解
		二维区间加，区间求最大值。二维线段树维护。

bzoj 2883
	题意
		N个数，支持一下两种操作。N,M<=100000
		U x y,讲第x个数修改成y；
		Q x y,计算从第x个数至第y个数中不同数的和并输出。如对于一段数{1,2,3,2,7}，它的值是13(1+2+3+7)。
	题解
		区间线段树套权值线段树/multiset

补充11.28_1 线段树合并
	线段树合并的复杂度是log的
	证明：合并相当于在一棵空的线段树里插入节点
