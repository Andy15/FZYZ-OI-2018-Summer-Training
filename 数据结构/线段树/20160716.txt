线段树及应用
	要求:
		信息可合并
		可Pushup(或不需Pushup)
		可Pushdown(或持久化，可通过均摊分析即可)
		且最大复杂度单次<O(N)
	支持:
		维护区间/链上(Dfs序)的基本信息
			可区间加，区间覆盖。
			可查最大值，区间和，区间gcd，前后缀最大值，维护凸包等。（不一定同时支持）
			较常配合离线处理
			bzoj 1012
			bzoj 1067
			bzoj 1099
			bzoj 1798
			bzoj 2957
			bzoj 3064
			bzoj 3226
			bzoj 3252
			bzoj 3339
			bzoj 3531
			bzoj 3533
			bzoj 3585
			bzoj 3589
			bzoj 3719
			bzoj 3779
			bzoj 3838
			bzoj 3922
			bzoj 3995
			bzoj 4262
			bzoj 4364
			bzoj 4415
			bzoj 4418
			bzoj 4527

bzoj 1012
	题意
		加入一个数，求后T个数的最小值。强制在线
	题解
		预先开好询问总数大小的线段树

bzoj 1067
	题意
		"X年是自Y年以来降雨量最多的":X年的降雨量不超过Y年，且对于任意Y＜Z＜X，Z年的降雨量严格小于X年。询问一句话是必真、必假还是“有可能”。
	题解
		离散化后维护是否可能为真/假，差别在空节点返回值

bzoj 1099
	题意
		定义一些树的不整齐程度|h1-h2|+|h2-h3|+……+|hn-1-hn|。允许交换两棵树。对于每个i，求出若交换的其中一棵树编号为i，则能获得的最小不整齐程度为多少。
	题解
		绝对值最后的展开形式，与hi与Minj,Maxj关系和hj与Mini,Maxi关系有关。一共有3×3=9种情况。对于有两组限制的情况，必须先排序处理第一维，再用线段树处理第二维。边界（1,N的位置，相邻情况）要特殊处理。//嘴巴AC还是很容易的。

bzoj 1798
	题意
		支持区间1>mul 2>add 3>sum
	题解
		维护mul，add，sum三个标记
		记得pushdown

bzoj 2957
	题意
		小A在平面上(0,0)点的位置，第i栋楼是(i,0)到(i,Hi)的线段。如果一栋楼房上任何一个高度大于0的点与(0,0)的连线没有与之前的线段相交，那么就被认为是可见的。求每天完工之后能看到多少栋楼房。
	题解
		一个显而易见的结论是，这种数字的值是单调递增的。我们修改一个数只会对这个数后面的数造成影响。考虑线段树划分出来的若干线段。这里有两种情况：
		1、某个线段中的最大值小于等于修改的数，那么这个线段的贡献为0，无需处理
		2、否则我们将这个线段分成两个并单独考虑，如果左侧的最大值大于修改的数，那么是不影响右侧的贡献的，只需递归处理左侧；否则就变成了第一种情况。O(Nlog^2N)

bzoj 3064
	题意
		Q X Y:询问从X到Y这段内CPU最高使用率
		A X Y:询问从X到Y这段内CPU达到过的历史最高使用率
		P X Y Z:使从X到Y这段内CPU使用率增加Z
		C X Y Z:使从X到Y这段内CPU使用率变为Z
	题解
		维护目前线段 最大值、覆盖值、增加值、
			历史线段 最大值、覆盖值、增加值

bzoj 3226
	题意
		5种运算如下：
		U T S∪T
		I T S∩T
		D T S－T
		C T T－S
		S T S⊕T
		一开始S为空集。给定多组T，形式为[或]或(或)
	题解
		每个数之间加入一个数
		[2,3) -> [2,2.5]
		(3,4] -> [3.5,4]
		U 区间涂1
		I 两侧区间涂0
		D 区间涂0
		C 两侧涂0,中间取反
		S 区间取反

bzoj 3252
	题意
		树版k取方格数（从根开始取，叶子结束）
	题解
		首先显然每次取最大权和的链
		对于链上的每个点x，要将x子树内的叶节点的权值和减去x的权值，因为下次取x子树的叶节点不能再次得到x的权值，用dfs+线段树就可以实现每次找叶节点最大值，以及修改子树权值

bzoj 3339/3585
	题意
		给定一个长度为N的数组，多次求[l,r]的mex（SG函数）。可离线。
	题解
		先把询问按l排序，容易得到1-i的sg值。由于mex不方便删除元素，所以考虑从左到右枚举l。Ans[l,r]=min(mex(1,i),{x|x in [1,l-1] but not in [l,r]})。考虑[l,r]和[l+1,r]的答案区别:删掉一个数a[l]，则l-next[l]-1的大于a[l]的sg值都会变成a[l]。所以问题转化为区间cmin，单点查询，用线段树解决。

bzoj 3531
	题意
		给出一个n个点的数，和m次操作。每个点有颜色和权值。
		每次操作分4种
		1：修改一个点的颜色
		2：修改一个点的权值
		3：询问从x到y的路径上，和x相同颜色的点的权值和（保证x，y同颜色）
		4：询问从x到y的路径上，和x相同颜色的点的权值最大值（保证x，y同颜色） 
	题解
		树链剖分，然后只要处理链上操作，考虑只询问一种颜色，按颜色将询问分类，修改看作加入和删除两个操作，线段树查询和以及最大值。O(nlog^2N)

bzoj 3533
	题意
		支持末尾加向量，查询[l,r]内的向量与(x,y)的点积最大值。强制在线。
	题解
		线段树维护凸包

bzoj 3589
	题意
		给定一棵树，支持子树加K，查询一些节点到根路径的并的权值和%2^31
	题解
		树链剖分+Dfs序，取出log个区间暴力合并

bzoj 3719
	题意
		给定一些矩形，求矩形合并后的面积和位置。N<=10^5
		矩形合并后成为包含原来两个矩形的最小矩形，平行于坐标轴。
	题解
		扫描线，线段树套vector

bzoj 3779
	题意
		给定一棵树，初始每个点都有一个颜色，支持三种操作：
		1.将某个点到根的路径上所有点染上一种新的颜色
		2.将某个点到根的路径上所有点染上一种新的颜色，然后把根设为这个点
		3.定义一个点的代价为这个点到根路径上颜色的种类数，求某个点子树中所有点代价的平均值
	题解
		1.Access 2.MakeRoot 3.用线段树维护DFS序维护信息，一旦LCT中出现了虚实边的切换，就在DFS序上对应的子树+1/-1，查询就直接在线段树上查就行了

bzoj 3838
	题意
		从两个长度为N的数列中选出k个，要求在A中选位置的均不在B之后，求选出的数的最小总和。
	题解
		每次选和最小的两个是最优的，因为如果不优，可以调换先后如下:
		A B        A B
		 ×   <==>  | |
		C D        C D
		即:将选取的A看成左括号，B看成右括号，那么答案是一个合法的括号序列。那么只要重复取出k对价值最小的左右括号，保证每时每刻都是一个合法的括号序列即可。
		将(看成1，)看成−1，设s[]为前缀和。
		如果当前取出的是()，那么对前缀和的影响为[A,B−1]区间加1。
		如果当前取出的是)(，那么对前缀和的影响为[B,A−1]区间减1，所以这种情况需要满足区间s的最小值不为0。
		考虑用线段树维护这个序列，维护:
		va:A≤B情况的最优解。
		vb:A>B情况的最优解，且满足[A,B−1]的区间s最小值大于当前区间的s最小值。
		vc:A>B情况的最优解。
		aa:区间内代价最小的A。
		ab:区间内代价最小的B。
		ba:区间内代价最小的A，满足[st,A−1]的区间s最小值大于区间s最小值。
		bb:区间内代价最小的B，满足[B,en]的区间s最小值大于区间s最小值。
		vm:区间s最小值。
		tag:区间增量标记。

bzoj 3922
	题意
		给定一个序列，支持以下操作:1对一段下标是等差数列的子序列进行求最大值操作(参见输入格式);2单点修改。
	题解
		大小暴力/线段树，O(n^5/3)或O(NsqrtNlogN)
bzoj 3995
	题意
		给定一个2*n的网格图，多次改变某条边的权值或询问y坐标在[l,r]中的2*(r-l+1)个点的MST。
	题解
	http://blog.csdn.net/popoqqq/article/details/45080183
	我们用线段树维护每个区间内的MST
	然后考虑合并 合并两个区间 我们会加入两条边 这样一定会形成一个环 切掉环上最大边 这题没了
	首先最大边一定在图中的彩色部分内 绿色部分可以O(1)求 我们需要维护的是红色和蓝色部分
	然后如果切掉的边是横边或者切掉的竖边不是区间唯一的竖边(如图中蓝色竖边) 那么红框和蓝框直接用左右区间的即可
	但是如果切掉了区间唯一的竖边(图中红色竖边)，那么就有些麻烦了
	首先我们需要知道切掉的是不是竖边 因此我们要记录每个区间的MST上最左侧和最右侧的竖边的权值
	然后还要记录区间内MST上竖边的数量
	然后如果切掉了红色的竖边 那么左侧的框被更新成了【左区间所有横边】【绿色边】【蓝色边】的最大值
	因此还要记录区间所有横边的最大长度
bzoj 4262
	题意
		A[i] = (1023^i mod 10^9) xor (1025^i mod 10^9)
		求
			for i in [l1, r1]
				for j in [max(i, l2), r2]
					Sum += max(A[i~j]) - min(A[i~j])
	题解
		最大值和最小值的问题是独立且相似的，考虑最大值：
		考虑离线，设ask(i,l,r)为以1到i为右端点时左端点在区间[l,r]内的区间最大值的和。
		从1到n枚举右端点，假设现在是i，那么可以通过单调栈求出最小的j使得[j,i]内a[i]是最大值。
		然后左端点在[j,i]区间内的所有区间最大值都应当变为a[i]，且所有答案应该加上本身的值。
		通过线段树打标记维护，时间复杂度O(nlogn)。
bzoj 4364
	题意
		区间cmincmax，最后一次查询
	题解
		打Mx,Mn两个标记即可

bzoj 4415
	题意
		一个1～N的序列，每次隔x张牌取1张（x张放在队尾），求取出牌的顺序
	题解
		线段树打一个size标记

bzoj 4418
	题意
		给定N个同心的扇形，求有多少面积，被至少K个扇形所覆盖。
	题解
		从左到右枚举每一个区间，遇到一个扇形的左区间就+1，遇到右区间就-1，然后再树状数组上2分答案，还是不会码log的

bzoj 4527
	题意
		一个数列为一个好的k-d数列，当且仅当我们在其中加上最多k个数之后，数列排序后为一个公差为d的等差数列。你有一个由n个整数组成的数列a。找到它的最长连续子串且为好的k-d数列。如果有多个最优答案，输出那个L值最小的。
	题解
		考虑扫右端点，设当前扫到了i，那么对于每个j<i，设xj=max{ak}(j≤k≤i),yj=min{ak}(j≤k≤i)，就是要求min{j}((xj−yj)−(i−j)≤k)，即min{j}(xj−yj+j≤k+i)。所以我们只需维护区间[l,r]中的min{xj−yj+j},min{xj+j},min{−yj+j},min{j}即可。然后每次扫到一个端点，将它最左合法左端点之前的点清为∞，将它左边第一个大于它的点+1到它这段区间的x覆盖为ai，将它左边第一个小于它的点+1到它这段区间的y覆盖为ai，然后查询的时候在线段树上二分即可。 
