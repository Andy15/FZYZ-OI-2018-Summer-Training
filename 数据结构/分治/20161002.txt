分治
	点分治
		基础强化
			yzoj 2434
			bzoj 1785
			bzoj 2051
			bzoj 2599
			bzoj 3522/4543
			bzoj 3672
			bzoj 3697
			bzoj 4016/yzoj 2076
			bzoj 4568
			bzoj 4598
			cf 372 div1 C (715 C)
			uoj 33
		动态点分治
			bzoj 1095
			bzoj 3435
			bzoj 3924
			bzoj 4012
	边分治
		yzoj 2283
	cdq分治
		
	线段树分治
		
	树链剖分

*点分治
yzoj 2434
	题意
		给定一棵树，求链的总数，使点权连起来是括号序列。
		N <= 10W
	题解
		点分治。
		对于一个点在一层分治中，关心其到根有多少左括号和右括号未被消掉。更进一步，消完必须只有朝向根的括号。
		从上往下递归，维护现在未被消掉的括号（最多为两部分），加入时能消直接消栈顶，并打标记表示是否匹配成功，删除时根据标记撤销。
		（必须打标记，否则不能区分)))是))+)得到还是)))(+)得到）。
		如果一个点代表的链消完只由一个方向括号组成，那么必须匹配只由另一个方向括号组成且数量相等的链。
		如果一个点代表的链消完是))((，那么一定不能全部消去。所以不用考虑。

yzoj 2283/bzoj 1095
	题意
		有 m 个操作，每次可以：
		C x:反转点 x 的颜色。
		A:查询树上最远的黑色点对的颜色距离。
		一开始都是黑色。
		n,m <= 10W
	题解
		每个节点开两个堆:
		第一个堆记录子树中所有节点到父亲节点的距离。
		第二个堆记录所有子节点的堆顶。
		那么一个节点的堆2中的最大和次大加起来就是子树中经过这个节点的最长链。
		然后我们最后开一个全局的堆，记录所有堆2中最大值和次大值之和，全局的堆顶就是答案。

bzoj 1785
	题意
		给定一棵树，询问长度在[l,r]范围内的路径中边权的平均值的最大值
	题解
		二分答案，点分治。
		二分答案，每条边权值减去答案，每次统计时我们要找有没有大于0的路径存在。
		对于一棵子树的每一个深度i记录一个路径权值和的最大值。
		对一个新的子树内的节点，在这棵子树之前的所有子树的深度可选范围就是[l-i,r-i]。
		单点修改，区间查最大值。用线段树维护。
		复杂度O(nlog^2nlogC)。

bzoj 2051
	题意
		给出一个N个结点的树，每条边有一个正整数权值，定义两个结点的距离为连接这两个结点路径上边权的和。对于每个结点i，它到其他N-1个结点都有一个距离，将这些距离从小到大排序，输出第K个距离。 
		N <= 50000
	题解
		预处理分治每层的所有点到分治中心的距离，以及中心每个子树内点到中心儿子的距离，排好序。
		枚举每个点，二分答案转为统计个数，然后对每个分治层，在排好序的数组二分位置即可。
		用分治中心所有答案减去枚举的点所在子树的答案。
		时间复杂度O(nlogn^3)，空间复杂度O(nlogn)。

bzoj 2599
	题意
		给一棵树,每条边有权.求一条路径,权值和等于K,且边的数量最小.N <= 200000, K <= 1000000
	题解
		点分治
		记录 Dis[x],Dep[x] 表示点 v 在当前子树的深度(一个距离为所有边权和，一个距离为边数)
		由于k不大，记录 v[y] 表示对于一个深度 y ，当前子树是否存在一个 Dis 为 y 的字节点（每次 Timer++ ，或者干脆以当前分治中心做 Timer ）， c[y] 则表示若 v[y]=Timer，其距离根节点的 Dep。

bzoj 3522/4543
	题意
		求树上三个点，使两两距离相等的点对个数。
	题解
		三个点不能在一条链上，那么必然有一个中心点。
		N ^ 2 暴力就是枚举中心点，树形Dp转移一下。
		令 f(x, j) 表示在以 x 点为根的子树中选一个点，且与 x 距离为 j 的节点数；g(x, j) 表示在以 x 为根的子树中选择两个点，再选一个节点 s 在 x 子树外，且与 x 的距离为 j 的方案数。
		第一步转移重儿子
		F[x] = F[t] - 1, G[x] = G[t] + 1
		统计答案
		Ans += F[x][j - 1] * G[t][j] + G[x][j + 1] * F[t][j]
		第二步转移其他儿子
		G[x][j - 1] += G[t][j];
		G[x][j + 1] += F[x][j + 1] * F[t][j];
		F[x][j + 1] += F[t][j];
		由于 d <= size[a]，可以Claris大法，但是由于f,g转移方向不同，要事先分配内存。

bzoj 3672 NOI2014购票

bzoj 3697
	题意
		给定一棵树，边有01边权，求有多少不同的链，满足链上01数量相等，并且存在链上一个点使得该点为分界左右01相等。
		N <= 10W
	题解
		点分治。问题就变成求过根满足条件的路径数。
		如何判断一条从根出发的路径是否包含分界点？只要在dfs中记录下这条路径的和x，同时用个标志数组判断这条路径是否存在前缀和为x的节点。
		这样我们枚举根节点的每个子树。用f[i][0…1]，g[i][0…1]分别表示前面几个子树以及当前子树和为i的路径数目，0和1用于区分路径上是否存在前缀和为i的节点。那么当前子树的贡献就是f[0][0] * g[0][0] + Σf [i][0] * g [-i][1] + f[i][1] * g[-i][0] + f[i][1] * g[-i][1]，其中i的范围[-d,d]，d为当前子树的深度。

bzoj 4016/yzoj 2076
	题意
		给定一张图，求最小字典序的最短路树，然后在这棵树上，求最长的包含K个点的简单路径长度和方案数。
	题解
		先求一个最短路图，然后再这个图上dfs。对于一个点的所有出点，按编号从小到大dfs。这样可以保证dfs树就是题目要求的树。
		然后在这棵树上跑树分治 <pair> f[j]表示之前已经做完的子树，从根出发链长为j的[最长长度,这个长度条件下的方案数]
		对于新的一棵子树，单独跑一个f’[j]意义一样，枚举这颗子树上链长，和f一起更新答案，然后用f’更新f。

bzoj 4568
	题意
		树上查两点间最大异或和
	题解
		点分治，每次求出重心后，求出重心到每个点路径上的数的线性基。
		对于每个询问，只需要暴力合并两个线性基即可。
		时间复杂度 O(60 n logn + 60 ^ 2 q)。

bzoj 4598 ??

cf 372 div1 C (715 C)
	题意
		求树上有多少条链，满足点权连成一个十进制数后可以被M整除。
		N <= 10W, M <= 10^9
	题解
		考虑点分治。
		对于一个中心，一条链如果作为后半段，那么可以通过长度以及%M的值得到对应前半段应该有的值。（预处理10^x的逆元）
		和一般点分治一样要减去子树内统计多的。比较好的方法是每次Dfs进一棵子树删掉贡献，再统计这棵子树和其他子树的答案。
		时间复杂度O(nlog^2n)，如果用Hash可以去掉一个log。

uoj 33

bzoj 3435 wc2014 紫荆花之恋

bzoj 3924
	题意
		给定一棵树，每个点有一个点权，多次改变某个点的点权，多次查询带权重心到所有点的带权距离之和。
	题解
		题目分为两个部分:查询带权中心，求一个点到所有点的距离之和。
		
		首先考虑如何计算一个点到所有点的带权距离之和且支持修改。
		询问的时候，对每个分治层考虑给定点过重心往外所连的权值和，一个点的答案是重心的所有答案减去这棵子树的答案。
		所以每个点记录子树中带权距离之和，以及权值之和(一层的答案要加上这个点到重心的距离*外部的权值之和)，再在每个子树中记录一个需要减掉的版本。
		
		怎么求带权中心呢？
		首先判断这个点是不是重心。如果已经是则完成。
		如果不是，重心肯定在和最大的儿子里，那么记录最大儿子，修改的时候沿路检查即可。
		时间复杂度nlogn

bzoj 4012
	题意
		给定一棵树，每个点有一个颜色，多次询问颜色在[l,r]区间内的所有点与某个点之间的距离之和，强制在线。
	题解
		动态点分治。
		先把问题转为前缀和。对于一个分治中心，考虑维护其所有子树内的点的<颜色，距离>，按颜色排序。
		查询一个点的时候和上题一样，对每个分治层考虑给定点过重心往外所连的权值和，贡献是重心的所有答案减去这棵子树的答案。在pair中二分即可。
		时间复杂度nlog^2n,空间nlogn。

*边分治
yzoj 2283/bzoj 1095
	题意
		有 m 个操作，每次可以：
		C x:反转点 x 的颜色。
		A:查询树上最远的黑色点对的颜色距离。
		一开始都是黑色。
		n,m <= 10W
	题解
		边分治的优点比起点分治来说，优点就是每次分治之后，只有两个分支，处理起来比较简单，代码比较好写。缺点就是需要添加虚点，常数比较大。
		边分治就是先添加虚点，使得每个节点的度数小于等于3，添加虚点的方法很容易看懂。
		做法是选在当前分治结构里面选一条边，使得边的两端最大联通块尽可能的小。
		对于一个分治结构，假设找到的分治的边为x-y，对于这个分治结构中的路径只有两种，不经过边x-y的和经过边x-y的，前者由子分治结构来考虑，现在只考虑后者。可以对边x-y两端分别维护两个大顶堆，堆里面放的是白色节点距离x的距离或者白色节点距离y的距离。所以经过x-y的最大路径就是两个堆的最大值加上x-y的边权。但是有修改操作，我们可以在堆里面再维护一个值，就是节点号x，如果堆顶的节点是黑色的话，说明这个节点已经不能用了，要pop掉。所以对每个节点要维护它所在的每一个分治结构，并且记录它是在分支结构的哪一边，更新的时候要沿着分治结构自底向上更新，最后询问的时候就是O(1)，更新是O(logn^2)。
		重建树:一个初始点有多个儿子，那么建立第一个新节点和第一个儿子一层，第二个新节点和第二个儿子一层...第i个新点向第i-1个连边，边权为0;第i个儿子向第i-1个的新点连边，边权为到初始点的距离。
		边分治:以本题边分治的过程为例，输入一条1-9的链的结果:
		备注:Solve x 表示递归进x这个点，x y 表示当前找到的分治中心边。
		Solve 1
		5 4
		Solve 5
		7 6
		Solve 7
		8 7
		Solve 8
		9 8
		Solve 9
		Solve 8
		Solve 7
		Solve 6
		5 6
		Solve 5
		Solve 6
		Solve 4
		2 3
		Solve 2
		1 2
		Solve 1
		Solve 2
		Solve 3
		4 3
		Solve 4
		Solve 3

