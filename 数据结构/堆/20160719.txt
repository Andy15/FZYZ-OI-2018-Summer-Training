堆
	手写堆
		yzoj 1242
　　　	bzoj 1150/2151/2288
　　　　	bzoj 2936
　　　　	bzoj 3575
　　　　	bzoj 3728
　　　　	bzoj 4425
　　　　	bzoj 1367

	可并堆/斜堆
		bzoj 1455
　　　bzoj 4054
	
　	可持久化堆
		yzoj 2173
		yzoj 2540	

堆	
bzoj 1150/2151/2288
	题意
		简化：给定一些数。求选K个数，要求两两不相邻。
	题解
		每次贪心选取距离最小的点，可能会影响到上下的点，那我就加入一个新节点 len[l]+len[r]-len[c]，以防以后后悔。
		什么意思呢，就是发现取了c点，再取一个另外的点不如取 l和r优，这时候就反悔，选上后来加入的c点，距离刚好是len[l]+len[r]。
		以后发现再不对了，就再修改，正确性是显然的。
	bzoj 1150
		差分后如上。
	bzoj 2288
		首先连在一块的正负相同的肯定可以看成一个点，然后我们就得到了一个正负交替的数列，并且首位两项都是正数（负数去掉）
		然后如果正的项数<=m，那显然我们全部选走就获得了最大权值，否则我们需要做一点牺牲。
		1）不选某些正项
		2）选一些负项使得相邻的正项成为1块
		记所有正数之和为sum，我们需要进行上面两种操作使得sum减掉的数最小并且满足只有m块。
		我们把所有数的绝对值放入一个堆，每次取最小元素x。sum'-=x
		那么如果该数原来是正的，意思是不选它；
		如果是负的，意思是把它两边的正数合并。
		但直接这样做是不行的，我们必须保证取负的时候两边的正的必须不被取，取正的时候两边的负的不被取。
		换句话说，不能选择相邻的两个数！我们成功的将此题转化成了数据备份问题。
	bzoj 2151
		双向链表连成环，其余同理。

bzoj 2936
	题意
		给定一个N×M的正方形小块，求出下雨后最多能积多少水。
	题解
		堆，Dfs，维护两个标记：是否遍历过，是否被水淹没。

bzoj 3575
	题意
		指定1-n的图，求对每条边，删一条最短路上边后的最短路长度。
	题解
		我们发现删边后的路径一定是这样的：起点->若干个原最短路径上的边->若干个非最短路径上的边->若干个原最短路径上的边->终点。
		我们发现其实就是不走原最短路径上的一个区间，并且删除的边一定在这个区间上。
		那么从S出发和到T跑到每个点的最短路，就可以得到每个点更新的区间的左右端点，从而用线段树维护区间cmin，单次查询的答案。

bzoj 3728
	题意
		给定n个灯泡和n个房间，每个灯泡有一个功率，每个房间有一个照亮的最小功率，可以换k个灯泡，求照亮所有房间的最小功率
	题解	
		将灯泡的功率和房间的最小功率排序，从大到小扫描每个房间
		对于一个房间，首先将能照亮这个房间的灯泡都加入堆
		如果堆为空则花掉一次换灯泡的机会换一个功率为这个房间的最小功率的灯泡
		否则取走功率最小的灯泡照亮这个房间，并将灯泡功率与房间最小功率的差值加入另一个堆
		结束时如果还有换灯泡的机会，就把第二个堆中最大的k个差值换掉

bzoj 4425
	题意
		一行两个整数n (1≤n≤300000) 研究员的数量n，以及m工作站在未锁定且没被使用的状态下超过m分钟会自动锁定。
		下面的n行，每一行两个整数a与s (1≤a,s≤100000000) 表示一个研究员在第a分钟时到达以及待了s分钟后离开。 
		输出研究者在离开时不锁定工作站最多可以使她节约多少次解锁工作。 
	题解
		按左端点排序，暴力加入，如果有多个先用最早会锁定的。堆维护。

可并堆
bzoj 1367
	题意
		给定一个长度为N的序列，每次可以把某个数+1或者-1，问多少次可以使序列递增。
	题解
		解法一
			设F[i][j]表示把第i个之前都变成j的最小次数。
			那么F[i][j]=min(F[i-1][1~j])+|a[i]-j|。
			对于一个i，维护函数fi(j)的下凸壳。那么fi(j)加上一个下凸的绝对值函数以后仍然是下凸的。
			现在证明这个函数的有用部分可以被分成不超过i段。首先，由于是前缀min，函数增的一部分的值都为中间的最小值。而每次从i转移到i+1都是增加一个绝对值函数，段数O(1)。
			堆维护。
		解法二
			根据题目性质，如果有一段连续的不增的值，那么肯定是把每个数都变成中位数最优。如果有一个新的不增的段的中位数大于当前段，那么可以把新的段都变成其中位数，最终变成数列的每个数是原先一些段的中位数。而新段的中位数小于当前段，则第一个段必须要变得更少，最后这两段都变成两段的中位数。
			可并堆维护。
		解法三
			考虑一个性质，如果a>b,那么要使a<=b,至少要b-a的代价;而花费b-a的代价，就可以同时把a,b变成a-b中的任意一个数。简称a与b匹配。
			而对于已经有的一个序列a1<a2<..<an,插入一个b<an,那么在花费b-an的代价下，把an和b都变成b是最优的。
			但是b可能小于其中某个ai(i<N)。不妨先将an调整为b，现在证明最后一定可以调整其合法，且代价为0。如果存在一个x使得对于1~n-1,an,b不能调整为an。不妨假设x与an-1匹配。那么首先有ai(不妨看作an-1)<an,因为an是当前最大，并且an-1>b，否则b会参与x的调整。此时b<an-1<an，而an-1是x代价为0的调整的上界。
			这个性质对所有(匹配，匹配)都成立，故此种调整方式成立。
			堆维护。

bzoj 4054
　　　题意
　　　一棵树上，勇者在1号点，初始血量是0。每个点有一个权值，踩上去血量会加上deltai，这个值可正可负。勇者任何时候血量不能低于0。问勇者能否到达某个目标点T。
　　　1≤n≤2*10^5,　6≤deltai≤10^6
　　　题解
　　　考虑记录F(i,j)=k表示第i个节点花j走进去最多出来为k。
　　　怎么去掉重复状态呢？
　　　首先如果j>k，那么这个状态没有意义。
　　　其次如果j1<j2而k1>k2，那么(j2,k2)没有意义。
　　　考虑树形Dp的时候合并状态。直观地考虑，如果一个点的权值为负，那么子树内所有F(i,j)的j都要加上一个代价；如果一个点的权值为正，那么子树内所有F(i,j)的k都会加上一个贡献。然而这样是不完善的：实际上一个点如果是正的，应该先消去子树内点的代价，再加上收益。最后将子树中所有F(son,j)=k两两配对，接到i上面。
　　　考虑将(j,k)记为一个pair，将pair去掉无用状态后上传。
　　　假定一个节点有很多pair，我们希望(j,k)只与i有关，就必须强制如果儿子选，祖先一定选。否则一个节点的pair之间存在互相约束的关系。也就是祖先的j约束必须小于儿子的j。
　　　如果一个点的权值为v是正的，那么当前pair为(0,v)。考虑子树内转移过来一个pair(a,b),如果a<权值，那么选肯定更优，可以合并变为(0,v+b-a)。（当然也可以不边做边合并，最后一次性合并。）
　　　如果一个点的权值为v是负的，那么当前paie为(-v,0)。考虑经过了前几个儿子的转移这个pair变成(a1,b1)，并且这个儿子有一个pair(a2,b2)。如果b1>=a2，那么可以直接合并两个pair变成(a1,b1-a2+b2)。如果b1<a2，那么可以走进子树获得(a1-b1+a2,b2)的收益，也可以不走进去，保留(a1,a2)。如果做到某个时刻a1<a2且a1<b1，就可以不用合并了。如果选完第一种情况，a1仍然大于b1，那么这个pair(a1,b1)会对子树造成负的影响，就会用到第二种情况。
　　　我们希望第一种能尽量被取出来，并且a限制小的尽快取出来。用可并堆维护(j,k)，以j为关键字即可。

cf 671D
　　　题意
　　　给出一棵树，同时给出一些形如(u,v,w)的信息，表示覆盖u到v的路径需要w的代价。
　　　一条边可以被多次覆盖，且给出的信息满足v在1到u的路径上。
　　　求覆盖所有边的最小代价。
　　　题解
　　　考虑F(i,j)表示从i，底下的链还能支持往上走j步的最小代价。
　　　为了记录F(i,j)表示从i，底下的链还能支持走到j的最小代价。